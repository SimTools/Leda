//_____________________________________________________________________________
//
// ==========
//  TFFT.cxx
// ==========
//
//	C Version 1.0 by Steve Sampson, Public Domain
//
//	This program is based on the work by W. D. Stanley
//	and S. J. Peterson, Old Dominion University.
//
//	This program produces a Frequency Domain display
//	from the Time Domain data input using the Fast Fourier Transform.
//
//	The REAL data is generated by the in-phase (I) channel and the
//	IMAGINARY data is produced by the quadrature-phase (Q) channel of
//	a Doppler Radar receiver.  The middle filter is zero Hz.  Closing
//	targets are displayed to the right, and Opening targets to the left.
//
//	Note: With IMAGINARY data set to zero the output is a mirror image.
//
//	Usage:	fft  samples  input_data  output_data
//	Where 'samples' is a power of two
//
//	Array Version for Turbo C 1.5
//
//
//  FFT Ver1.1
//  This program is extend by K.Mori. Version 1.0 for Borland C++ 4.0 
//  Usage: fft [option] samples sample_frequency input output
//  option: /ri ...Real-Image input data(default)
//          /ro ...Real Only input data
//          /tr ...Time-Real input data(ignore Time)
//  Where samples is a power of 2
//

#include <math.h>
#if 0
#include <stdlib.h>
#include <iomanip.h>
#include <iostream.h>
#include <fstream.h>
#include <string.h>
#endif
#include "TFFT.h"

#define	TWO_PI	((double)2.0 * M_PI)

ClassImp(TFFT)

//_____________________________________________________________________________
//
// =========================================================================
//  TTFT::TTFT(int samples, double samplefreq, double real[], double imag[])
// =========================================================================
//
//
TFFT::TFFT(int samples, double samplefreq, double real[], double imag[])
{
	SetData(samples, samplefreq, real, imag);
}
   
//_____________________________________________________________________________
//
// ===================================================
//  void TFFT::SetData(int samples, double samplefreq, 
//                     double real[], double imag[])
// ===================================================
//
//
void TFFT::SetData(int samples, double samplefreq, 
                   double real[], double imag[])
{
	fNsamples   = samples;
	fPower      = (int)(log10((double)samples) / log10((double)2.0));
	fSampleFreq = samplefreq;

	for (int i = 0; i < fNsamples; i++) {
		fReal[i] = real[i];
		fImag[i] = imag[i];
	}	

	DoFFT();
}

//_____________________________________________________________________________
//
// ====================
//  void TFFT::DoFFT()
// ====================
//
//  Do Fast Fourier transform.
// 
void TFFT::DoFFT()
{
	fDone = true;
	unsigned i1, i2, i3, i4, y;
	int	 loop, loop1, loop2;
	double	 a1, a2, b1, b2, z1, z2, v;

	/* Scale the data */

	for (loop = 0; loop < fNsamples; loop++)  {
		fReal[loop] /= (double)fNsamples;
		fImag[loop] /= (double)fNsamples;
	}

	i1 = fNsamples >> 1;
	i2 = 1;
	v = TWO_PI * ((double)1.0 / (double)fNsamples);

	for (loop = 0; loop < fPower; loop++)  {
		i3 = 0;
		i4 = i1;

		for (loop1 = 0; (unsigned)loop1 < i2; loop1++)  {
			y = Permute((i3 / i1));
			z1 =  cos(v * y);
			z2 = -sin(v * y);

			for (loop2 = i3; (unsigned)loop2 < i4; loop2++)  {
				a1 = fReal[loop2];
				a2 = fImag[loop2];

				b1 = z1*fReal[loop2+i1] - z2*fImag[loop2+i1];
				b2 = z2*fReal[loop2+i1] + z1*fImag[loop2+i1];

				fReal[loop2]      = a1 + b1;
				fImag[loop2]      = a2 + b2;

				fReal[loop2 + i1] = a1 - b1;
				fImag[loop2 + i1] = a2 - b2;
			}

			i3 += (i1 << 1);
			i4 += (i1 << 1);
		}

		i1 >>= 1;
		i2 <<= 1;
	}

	fMaxAmp = (double)0.0;
	for (int i = 0; i < fNsamples; i++)  {
		double mag;
		if ((mag = GetMagnitude(i)) > fMaxAmp) fMaxAmp = mag;
	}
}

//_____________________________________________________________________________
//
// ==========================
//  double TFFT::GetMaxAmp()
// ==========================
// 
//  Find maximum amplitude
//
double TFFT::GetMaxAmp()
{
	if (!fDone) DoFFT();
	return fMaxAmp;
}


//_____________________________________________________________________________
//
// ==================================
//  double TFFT::GetMagnitude(int n)
// ==================================
// 
//  Calculate Power Magnitude
//
double TFFT::GetMagnitude(int n)
{
	if (!fDone) DoFFT();
	n = Permute(n);
	return (sqrt(fReal[n] * fReal[n] + fImag[n] * fImag[n]));
}


//_____________________________________________________________________________
//
// ==================================
//  double TFFT::GetFrequency(int n)
// ==================================
// 
//  Calculate frequency for index n.
//
double TFFT::GetFrequency(int n)
{
	if (!fDone) DoFFT();
	double freq; 
	if (n >= fNsamples/2) freq = -fSampleFreq*(fNsamples-n)/fNsamples;
	else                  freq =  fSampleFreq*(n)/fNsamples;
	return freq;
}
//_____________________________________________________________________________
//
// ==============================
//  int TFFT::Permute(int index)
// ==============================
// 
//  Bit reverse the number
//  Changes 11100000b to 00000111b or vice-versa

int TFFT::Permute(int index)
{
	int n1     = fNsamples;
	int result = 0;

	for (int i = 0; i < fPower; i++)  {
		n1 >>= 1;			/* n1 / 2.0 */
		if (index < n1) continue;

		result += (int) pow((double)2.0, (double)i);
		index -= n1;
	}

	return result;
}

//_____________________________________________________________________________
//
// =======================================
//  void TFFT::GetResult(double result[])
// =======================================
// 
//  Get result of FFT.
//
void TFFT::GetResult(double result[][2])
{
	int n = fNsamples / 2;
	int m = 0;
	for (int i = n; i < fNsamples; i++)  {
		result[m][0] = GetFrequency(i);
		result[m][1] = GetMagnitude(i);
		m++;
	}

	for (int i = 0; i < n; i++)  {
		result[m][0] = GetFrequency(i);
		result[m][1] = GetMagnitude(i);
		m++;
	}
}
